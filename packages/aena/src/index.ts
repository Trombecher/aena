// Re-export commonly used things.

export {Box} from "./box";
export {BoxSet} from "./set";
export {BoxArray} from "./array";
export {BoxMap} from "./map";

export {
    createElement,
    Fragment,
    JSX,
    mount
} from "./jsx-runtime";

import {Box} from "./box";
import {isObject} from "./internal";

/**
 * Maps an array of boxes to their unboxed equivalents.
 */
export type UnboxArray<A extends Box<any>[]> = {
    [K in keyof A]: A[K] extends Box<infer U> ? U : never;
};

/**
 * Maps a tuple `T` to an array of boxes of each tuple element.
 */
export type IntoBoxArray<T extends any[]> = {
    [K in keyof T]: Box<T[K]>;
};

/**
 * Derives a single {@link Box} from multiple boxes (dependencies).
 * Whenever one dependency changes, the resulting {@link Box} will change to the value generated by the reducer.
 *
 * The `as const` type annotation **is needed** for typing to work.
 *
 * # Example
 *
 * ```ts
 * import {reduce} from "aena";
 *
 * const boxedNumber = new Box(0);
 * const boxedString = new Box("foo");
 *
 * const repeated = reduce([boxedNumber, boxedString] as const, ([n, s]) => s.repeat(n));
 * ```
 */
export function reduce<V extends Box<any>[], T>(
    dependencies: V,
    reducer: (values: UnboxArray<V>) => T
): Readonly<Box<T>> {
    const values = dependencies.map(d => d!.value) as UnboxArray<V>;

    const reducedBox = new Box(reducer(values));
    dependencies.forEach((box, index) => box!.attach(value => {
        values[index] = value;
        reducedBox.value = reducer(values);
    }));

    return reducedBox;
}

/**
 * Checks if parameter `o` is instance of a class implementing {@link Listen}.
 */
export function isInstanceOfListen<L extends Function>(o: object): o is Listen<L> {
    return "attach" in o && "detach" in o;
}

/**
 * Checks if parameter `o` is instance of a class implementing {@link ListenDeep}.
 */
export function isInstanceOfListenDeep<L extends Function>(o: object): o is ListenDeep<L> {
    return "attach" in o
        && "detach" in o
        && "attachDeep" in o
        && "detachDeep" in o;
}

/**
 * The standard deep listener type.
 *
 * Extracted to a separate type due to flexibility.
 */
export type DeepListener = () => void;

/**
 * The basic interface for reactivity / signals.
 *
 * # Example
 *
 * ```ts
 * const boxed = new Box(0);
 *
 * // Add a listener.
 * const listener = boxed.addListener(value => console.log(value));
 *
 * // ...
 *
 * // Remove the listener
 * boxed.removeListener(listener);
 * ```
 */
export interface Listen<L extends Function = Function> {
    /**
     * Add a listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    attach(listener: L): L;

    /**
     * Remove a listener.
     */
    detach(listener: L): void;
}

/**
 * The extended interface useful for types which contain mutable data.
 *
 * Listening "deep" ensures that all boxed descendants of the implementation of this interface have this listener.
 *
 * # Example
 *
 * ```typescript
 * import {BoxSet} from "aena";
 *
 * // `BoxSet<T>` implements `ListenDeep<Listener<T>>`.
 * const boxedParent = new BoxSet();
 *
 * // Add listener.
 * const listener = boxedParent.addDeepListener(() => console.log("Update"));
 *
 * // ...
 *
 * // Remove listener.
 * boxedParent.removeDeepListener(listener);
 * ```
 */
export interface ListenDeep<L extends Function = Function> extends Listen<L> {
    /**
     * Add a deep listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    attachDeep(listener: DeepListener): DeepListener;

    /**
     * Remove a deep listener.
     */
    detachDeep(listener: DeepListener): void;
}

/**
 * If `value` is an object, it adds the given `listener` to all boxed descendants.
 */
export function addListenerRecursively(value: any, listener: DeepListener): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.attachDeep(listener);
    else if(isInstanceOfListen(value)) value.attach(listener);
    else Object.keys(value).forEach(key =>
            addListenerRecursively(value[key as keyof typeof value], listener));
}

/**
 * If `value` is an object, it removes the given `listener` from all boxed descendants.
 */
export function removeListenerRecursively(value: any, listener: DeepListener): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.detachDeep(listener);
    else if(isInstanceOfListen(value)) value.detach(listener);
    else Object.keys(value).forEach(key =>
            removeListenerRecursively(value[key as keyof typeof value], listener));
}