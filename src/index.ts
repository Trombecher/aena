// Re-export commonly used things.

export {Box, WritableBox} from "./box";
export {BoxSet} from "./set";
export {BoxArray} from "./array";
export {BoxMap} from "./map";

export {
    createElement,
    Fragment,
    JSX,
    mount
} from "./jsx-runtime";

import {Box, WritableBox} from "./box";
import {BoxMap} from "./map";
import {BoxSet} from "./set";
import {BoxArray} from "./array";
import {isObject} from "./internal";

export const enum BoxIdentifier {
    WritableBox = 0,
    Box = 1,
    BoxSet = 2,
    BoxMap = 3,
    BoxArray = 4
}

/**
 * Maps an array of boxes to their unboxed equivalents.
 */
export type UnboxArray<A extends Box<any>[]> = {
    [K in keyof A]: A[K] extends Box<infer U> ? U : never;
};

/**
 * Maps a tuple `T` to an array of boxes of each tuple element.
 */
export type IntoBoxArray<T extends any[]> = {
    [K in keyof T]: Box<T[K]>;
};

/**
 *
 * Assumes that `obj` does not have a `""` property.
 * @param obj
 * @experimental
 */
export function serialize<O extends Omit<object, "">>(obj: O) {
    return JSON.stringify(obj, (_, value) => {
        if(value instanceof WritableBox) return {"": BoxIdentifier.WritableBox, v: value.value};
        if(value instanceof Box) return {"": BoxIdentifier.Box, v: value.value};
        if(value instanceof BoxSet) return {"": BoxIdentifier.BoxSet, v: value.reduce(new Array<any>(), x => x)};
        if(value instanceof BoxMap) return {"": BoxIdentifier.BoxMap, v: Array.from(value.entries())};
        if(value instanceof BoxArray) return {"": BoxIdentifier.BoxArray, v: value.toArray()};
        return value;
    });
}

/**
 * Deserializes a string `s` serialized with {@link serialize}.
 * @experimental
 */
export function deserialize<O extends Omit<object, "">>(s: string): O {
    return JSON.parse(s, (_, value: {
        "": BoxIdentifier,
        v: any
    } | {
        [_: string | number | symbol]: any
    }) => {
        if(!isObject(value)) return value;
        switch(value[""]) {
            case BoxIdentifier.WritableBox:
                return new WritableBox(value.v);
            case BoxIdentifier.Box:
                return new Box(value.v);
            case BoxIdentifier.BoxSet:
                const set = new BoxSet();
                (value.v as unknown[]).forEach(v => set.add(v));
                return set;
            case BoxIdentifier.BoxMap:
                const map = new BoxMap();
                (value.v as [unknown, unknown][]).forEach(([k, v]) => map.set(k, v));
                return map;
            case BoxIdentifier.BoxArray:
                return new BoxArray(value.v);
            default:
                return value;
        }
    }) as O;
}

/**
 * Derives a single {@link Box} from multiple boxes (dependencies).
 * Whenever one dependency changes, the resulting {@link Box} will change to the value generated by the reducer.
 *
 * The `as const` type annotation **is needed** for typing to work.
 *
 * # Example
 *
 * ```ts
 * import {reduce} from "aena";
 *
 * const boxedNumber = new Box(0);
 * const boxedString = new Box("foo");
 *
 * const repeated = reduce([boxedNumber, boxedString] as const, ([n, s]) => s.repeat(n));
 * ```
 */
export function reduce<V extends Box<any>[], T>(
    dependencies: V,
    reducer: (values: UnboxArray<V>) => T
): Box<T> {
    const values = dependencies.map(d => d!.value) as UnboxArray<V>;

    const reducedBox = new WritableBox(reducer(values));
    dependencies.forEach((box, index) => box!.addListener(value => {
        values[index] = value;
        reducedBox.value = reducer(values);
    }));
    return reducedBox;
}

/**
 * Checks if parameter `o` is instance of a class implementing {@link Listen}.
 */
export function isInstanceOfListen<L extends Function>(o: object): o is Listen<L> {
    return "addListener" in o && "removeListener" in o;
}

/**
 * Checks if parameter `o` is instance of a class implementing {@link ListenDeep}.
 */
export function isInstanceOfListenDeep<L extends Function>(o: object): o is ListenDeep<L> {
    return "addListener" in o
        && "removeListener" in o
        && "addDeepListener" in o
        && "removeDeepListener" in o;
}

/**
 * The standard listener type.
 */
export type Listener<C> = (change: C) => void;

/**
 * The standard deep listener type.
 *
 * Extracted to a separate type due to flexibility.
 */
export type DeepListener = () => void;

/**
 * The basic interface for reactivity / signals.
 *
 * # Example
 *
 * ```ts
 * const boxed = new Box(0);
 *
 * // Add a listener.
 * const listener = boxed.addListener(value => console.log(value));
 *
 * // ...
 *
 * // Remove the listener
 * boxed.removeListener(listener);
 * ```
 */
export interface Listen<C> {
    /**
     * Add a listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    addListener(listener: Listener<C>): Listener<C>;

    /**
     * Remove a listener.
     */
    removeListener(listener: Listener<C>): void;
}

/**
 * The extended interface useful for types which contain mutable data.
 *
 * Listening "deep" ensures that all boxed descendants of the implementation of this interface have this listener.
 *
 * # Example
 *
 * ```typescript
 * import {BoxSet} from "aena";
 *
 * // `BoxSet<T>` implements `ListenDeep<Listener<T>>`.
 * const boxedParent = new BoxSet();
 *
 * // Add listener.
 * const listener = boxedParent.addDeepListener(() => console.log("Update"));
 *
 * // ...
 *
 * // Remove listener.
 * boxedParent.removeDeepListener(listener);
 * ```
 */
export interface ListenDeep<C> extends Listen<C> {
    /**
     * Add a deep listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    addDeepListener(listener: DeepListener): DeepListener;

    /**
     * Remove a deep listener.
     */
    removeDeepListener(listener: DeepListener): void;
}

/**
 * If `value` is an object, it adds the given `listener` to all boxed descendants.
 */
export function addListenerRecursively(value: any, listener: DeepListener): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.addDeepListener(listener);
    else if(isInstanceOfListen(value)) value.addListener(listener);
    else Object.keys(value).forEach(key =>
            addListenerRecursively(value[key as keyof typeof value], listener));
}

/**
 * If `value` is an object, it removes the given `listener` from all boxed descendants.
 */
export function removeListenerRecursively(value: any, listener: DeepListener): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.removeDeepListener(listener);
    else if(isInstanceOfListen(value)) value.removeListener(listener);
    else Object.keys(value).forEach(key =>
            removeListenerRecursively(value[key as keyof typeof value], listener));
}