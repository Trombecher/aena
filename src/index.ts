export {Box, WritableBox} from "./box";
export {BoxSet} from "./set";
export {BoxArray} from "./array";
export {BoxMap} from "./map";

export {
    createElement,
    Fragment,
    JSX,
    mount
} from "./jsx-runtime";

import {Box, WritableBox} from "./box";
import {BoxMap} from "./map";
import {BoxSet} from "./set";
import {BoxArray} from "./array";

export enum BoxIdentifier {
    WritableBox = 0,
    Box = 1,
    BoxSet = 2,
    BoxMap = 3,
    BoxArray = 4
}

/**
 * Infers the type `T` of `Box<T>`.
 */
export type Unbox<B> = B extends Box<infer T> ? T : never;

export type UnboxArray<A extends Box<any>[]> = {
    [K in keyof A]: A[K] extends Box<infer U> ? U : never;
};

/**
 * Maps a tuple `T` to an array of boxes of each tuple element.
 */
export type IntoBoxArray<T extends any[]> = {
    [K in keyof T]: Box<T[K]>;
};

/**
 * Assumes that `obj` does not have a `""` property.
 * @param obj
 */
export function serialize<O extends Omit<object, "">>(obj: O) {
    return JSON.stringify(obj, (_, value) => {
        if(value instanceof WritableBox) return {"": BoxIdentifier.WritableBox, v: value.value};
        if(value instanceof Box) return {"": BoxIdentifier.Box, v: value.value};
        if(value instanceof BoxSet) return {"": BoxIdentifier.BoxSet, v: value.map(x => x)};
        if(value instanceof BoxMap) return {"": BoxIdentifier.BoxMap, v: Array.from(value.entries())}
        if(value instanceof BoxArray) return {"": BoxIdentifier.BoxArray, v: value.toArray()};
        return value;
    });
}

export function deserialize<O extends Omit<object, "">>(s: string): O {
    return JSON.parse(s, (_, value: {
        "": BoxIdentifier,
        v: any
    } | {
        [_: string | number | symbol]: any
    }) => {
        if(!isObject(value)) return value;
        switch(value[""]) {
            case BoxIdentifier.WritableBox:
                return new WritableBox(value.v);
            case BoxIdentifier.Box:
                return new Box(value.v);
            case BoxIdentifier.BoxSet:
                const set = new BoxSet();
                (value.v as unknown[]).forEach(v => set.add(v));
                return set;
            case BoxIdentifier.BoxMap:
                const map = new BoxMap();
                (value.v as [unknown, unknown][]).forEach(([k, v]) => map.set(k, v));
                return map;
            case BoxIdentifier.BoxArray:
                return new BoxArray(value.v);
            default:
                return value;
        }
    }) as O;
}

/**
 * Derives a single `Box` from multiple `Box`es (dependencies).
 * Whenever one dependency changes, the resulting `Box` will change to the value generated by the reducer.
 *
 * The `as const` type annotation **is needed** for typing to work.
 *
 * # Example
 *
 * ```
 * import {reduce} from "aena/state";
 *
 * const boxedNumber = new Box(0);
 * const boxedString = new Box("foo");
 *
 * const repeated = reduce([boxedNumber, boxedString] as const, ([n, s]) => s.repeat(n));
 * ```
 */
export function reduce<V extends any[], T>(
    dependencies: Readonly<IntoBoxArray<V>>,
    reducer: (values: V) => T
): Box<T> {
    const values = dependencies.map(d => d!.value) as V;

    const reducedBox = new WritableBox(reducer(values));
    dependencies.forEach((box, index) => box!.addListener(value => {
        values[index] = value;
        reducedBox.value = reducer(values);
    }));
    return reducedBox;
}

/**
 * Checks if parameter `o` is instance of a class implementing `Boxed`.
 *
 * More precisely, it checks if the prototype of `o` has the two required functions.
 */
export function isInstanceOfListen<L extends Function>(o: object): o is Listen<L> {
    return "addListener" in o && "removeListener" in o;
}

/**
 * Checks if parameter `o` is instance of a class implementing `BoxedParent`.
 *
 * More precisely, it checks if the prototype of `o` has the two required functions.
 */
export function isInstanceOfListenDeep<L extends Function>(o: object): o is ListenDeep<L> {
    return "addListener" in o
        && "removeListener" in o
        && "addDeepListener" in o
        && "removeDeepListener" in o;
}

/**
 * The standard deep listener type.
 *
 * Extracted to a separate type due to easy api adjustments.
 */
export type DeepListener = () => void;

/**
 * The basic interface for reactivity / signals.
 *
 * # Example
 *
 * ```typescript
 * const boxed = new Box(0);
 *
 * // Add a listener.
 * const listener = boxed.addListener(value => console.log(value));
 *
 * // ...
 *
 * // Remove the listener
 * boxed.removeListener(listener);
 * ```
 */
export interface Listen<L extends Function> {
    /**
     * Add a listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    addListener(listener: L): L;

    /**
     * Remove a listener.
     */
    removeListener(listener: L): void;
}

/**
 * The extended interface useful for types which contain mutable data.
 *
 * Listening `deep` ensures that all boxed descendants of the implementation of this interface have this listener.
 *
 * # Example
 *
 * ```typescript
 * import {Listener} from "aena/state/set";
 *
 * // `BoxSet<T>` implements `Boxed<Listener<T>>`.
 * const boxedParent = new BoxSet();
 *
 * // Add listener.
 * const listener = boxedParent.addDeepListener(() => console.log("Update"));
 *
 * // ...
 *
 * // Remove listener.
 * boxedParent.removeDeepListener(listener);
 * ```
 */
export interface ListenDeep<L extends Function> extends Listen<L> {
    /**
     * Add a deep listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    addDeepListener(listener: DeepListener): DeepListener;

    /**
     * Remove a deep listener.
     */
    removeDeepListener(listener: DeepListener): void;
}

/**
 * If `value` is an object, it adds the given listener to all boxed descendants.
 */
export function addListenerRecursive(value: any, listener: () => void): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.addDeepListener(listener);
    else if(isInstanceOfListen(value)) value.addListener(listener);
    else Object.keys(value).forEach(key =>
            addListenerRecursive(value[key as keyof typeof value], listener));
}

/**
 * If `value` is an object, it removes the given listener from all boxed descendants.
 */
export function removeListenerRecursive(value: any, listener: () => void): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.removeDeepListener(listener);
    else if(isInstanceOfListen(value)) value.removeListener(listener);
    else Object.keys(value).forEach(key =>
            removeListenerRecursive(value[key as keyof typeof value], listener));
}

/**
 * Checks if the parameter `value` is an object and not null.
 */
export function isObject(value: any): value is object {
    return typeof value === "object" && value !== null;
}