// Re-export commonly used things.

export {Box, ReadonlyBox} from "./box";
export {BoxSet} from "./set";
export {BoxArray} from "./array";
export {BoxMap} from "./map";

export {
    createElement,
    Fragment,
    JSX,
    mount
} from "./jsx-runtime";

import {Box, ReadonlyBox} from "./box";
import {isObject} from "./internal";

/**
 * Maps an array of boxes to their unboxed equivalents.
 */
export type UnboxArray<A extends Box<any>[]> = {
    [K in keyof A]: A[K] extends Box<infer U> ? U : never;
};

/**
 * Maps a tuple `T` to an array of boxes of each tuple element.
 */
export type IntoBoxArray<T extends any[]> = {
    [K in keyof T]: Box<T[K]>;
};

/**
 * Derives a single {@link Box} from multiple boxes (dependencies).
 * Whenever one dependency changes, the resulting {@link Box} will change to the value generated by the reducer.
 *
 * The `as const` type annotation **is needed** for typing to work.
 *
 * # Example
 *
 * ```ts
 * import {reduce} from "aena";
 *
 * const boxedNumber = new Box(0);
 * const boxedString = new Box("foo");
 *
 * const repeated = reduce([boxedNumber, boxedString] as const, ([n, s]) => s.repeat(n));
 * ```
 */
export function reduce<V extends Box<any>[], T>(
    dependencies: V,
    reducer: (values: UnboxArray<V>) => T
): ReadonlyBox<T> {
    const values = dependencies.map(d => d!.value) as UnboxArray<V>;

    const reducedBox = new Box(reducer(values));
    dependencies.forEach((box, index) => box!.addListener(value => {
        values[index] = value;
        reducedBox.value = reducer(values);
    }));

    return reducedBox.readonly();
}

/**
 * Checks if parameter `o` is instance of a class implementing {@link Listen}.
 */
export function isInstanceOfListen<L extends Function>(o: object): o is Listen<L> {
    return "addListener" in o && "removeListener" in o;
}

/**
 * Checks if parameter `o` is instance of a class implementing {@link ListenDeep}.
 */
export function isInstanceOfListenDeep<L extends Function>(o: object): o is ListenDeep<L> {
    return "addListener" in o
        && "removeListener" in o
        && "addDeepListener" in o
        && "removeDeepListener" in o;
}

/**
 * The standard listener type.
 */
export type Listener<C> = (change: C) => void;

/**
 * The standard deep listener type.
 *
 * Extracted to a separate type due to flexibility.
 */
export type DeepListener = () => void;

/**
 * The basic interface for reactivity / signals.
 *
 * # Example
 *
 * ```ts
 * const boxed = new Box(0);
 *
 * // Add a listener.
 * const listener = boxed.addListener(value => console.log(value));
 *
 * // ...
 *
 * // Remove the listener
 * boxed.removeListener(listener);
 * ```
 */
export interface Listen<C> {
    /**
     * Add a listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    addListener(listener: Listener<C>): Listener<C>;

    /**
     * Remove a listener.
     */
    removeListener(listener: Listener<C>): void;
}

/**
 * The extended interface useful for types which contain mutable data.
 *
 * Listening "deep" ensures that all boxed descendants of the implementation of this interface have this listener.
 *
 * # Example
 *
 * ```typescript
 * import {BoxSet} from "aena";
 *
 * // `BoxSet<T>` implements `ListenDeep<Listener<T>>`.
 * const boxedParent = new BoxSet();
 *
 * // Add listener.
 * const listener = boxedParent.addDeepListener(() => console.log("Update"));
 *
 * // ...
 *
 * // Remove listener.
 * boxedParent.removeDeepListener(listener);
 * ```
 */
export interface ListenDeep<C> extends Listen<C> {
    /**
     * Add a deep listener.
     *
     * @returns The parameter `listener` for lazy typing.
     */
    addDeepListener(listener: DeepListener): DeepListener;

    /**
     * Remove a deep listener.
     */
    removeDeepListener(listener: DeepListener): void;
}

/**
 * If `value` is an object, it adds the given `listener` to all boxed descendants.
 */
export function addListenerRecursively(value: any, listener: DeepListener): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.addDeepListener(listener);
    else if(isInstanceOfListen(value)) value.addListener(listener);
    else Object.keys(value).forEach(key =>
            addListenerRecursively(value[key as keyof typeof value], listener));
}

/**
 * If `value` is an object, it removes the given `listener` from all boxed descendants.
 */
export function removeListenerRecursively(value: any, listener: DeepListener): void {
    if(!isObject(value)) return;

    if(isInstanceOfListenDeep(value)) value.removeDeepListener(listener);
    else if(isInstanceOfListen(value)) value.removeListener(listener);
    else Object.keys(value).forEach(key =>
            removeListenerRecursively(value[key as keyof typeof value], listener));
}

/**
 * Maps the index according to the following pattern:
 *
 * - If `index < -length`: return `0`
 * - If `index < 0`: return `index + length`
 * - If `index >= length`: return `length - 1`
 * - Else: return `index`
 *
 * This map ensures that the returned index is always valid.
 */
export function clampIndex(index: number, length: number): number {
    index = clampIndexLower(index, length);
    if(index >= length) return length - 1;
    return index;
}

/**
 * Maps the index according to the following pattern.
 *
 * - If `index < -length`: return `0`
 * - If `index < 0`: return `index + length`
 * - If `index > length`: return `length`
 * - Else: return `index`
 *
 * This map ensures a valid _target_ index up to (including) `length`.
 */
export function clampIndexUpTo(index: number, length: number): number {
    index = clampIndexLower(index, length);
    if(index > length) return length;
    return index;
}

/**
 * Maps the index according to the following pattern:
 *
 * - If `index < -length`: return `0`
 * - If `index < 0`: return `index + length`
 * - Else: return `index`
 *
 * This map ensures that the index is always positive, but validity is not ensured.
 */
export function clampIndexLower(index: number, length: number): number {
    if(index < -length) return 0;
    if(index < 0) return index + length;
    return index;
}