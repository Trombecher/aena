export {Box} from "./box";
export {BoxSet} from "./set";
export {BoxArray} from "./array";
export {BoxMap} from "./map";

import {Box} from "./box";

/**
 * Derives a single `Box` from multiple `Box`es (dependencies).
 * Whenever one dependency changes, the resulting `Box` will change to the value generated by the reducer.
 *
 * This function supports a maximum of 26 dependencies for typing (it is very unlikely to have more than 26 different types at compile-time)
 * but - ignoring typing - you can pass a variable length array of dependencies into this function.
 */
export function reduce<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, $>(
    dependencies: [
        Box<A>, Box<B>, Box<C>?, Box<D>?, Box<E>?, Box<F>?, Box<G>?, Box<H>?, Box<I>?,
        Box<J>?, Box<K>?, Box<L>?, Box<M>?, Box<N>?, Box<O>?, Box<P>?, Box<Q>?, Box<R>?,
        Box<S>?, Box<T>?, Box<U>?, Box<V>?, Box<W>?, Box<X>?, Box<Y>?, Box<Z>?
    ],
    reducer: (values: [A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]) => $
): Box<$> {
    const values = dependencies.map(d => d!.value);
    // @ts-ignore
    const reducedBox = new Box(reducer(values));
    dependencies.forEach((box, index) => box!.onChange(value => {
        values[index] = value;
        // this works, I promise!
        // @ts-ignore
        reducedBox.value = reducer(values);
    }));
    return reducedBox;
}

/**
 * Call this "unlistener" function to remove the listener you attached.
 */
export type Unlistener = () => void;